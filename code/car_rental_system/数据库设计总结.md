# 租车管理系统数据库设计总结

## 概述
为租车管理系统设计了完整的数据库模型，包含三个主要数据模型：车辆(Vehicle)、客户(Customer)和租赁订单(Rental)。

## 数据模型

### 1. 车辆模型 (Vehicle)
**表名**: vehicles
**主键**: id (BigAutoField)

| 字段名 | 类型 | 长度 | 约束 | 说明 |
|--------|------|------|------|------|
| license_plate | CharField | 20 | UNIQUE, NOT NULL | 车牌号（唯一标识）|
| brand | CharField | 50 | NOT NULL | 汽车品牌 |
| model | CharField | 50 | NOT NULL | 汽车型号 |
| vehicle_type | CharField | 20 | NOT NULL | 车辆类型（轿车/SUV/MPV等）|
| color | CharField | 20 | NOT NULL | 车身颜色 |
| daily_rate | DecimalField | 10,2 | NOT NULL, MIN>0 | 每日租金 |
| status | CharField | 20 | NOT NULL, 有选择项 | 车辆状态 |
| created_at | DateTimeField | - | NOT NULL | 创建时间 |
| updated_at | DateTimeField | - | NOT NULL | 更新时间 |

**状态选项**:
- AVAILABLE: 可用
- RENTED: 已租
- MAINTENANCE: 维修中

**索引**:
- license_plate (UNIQUE)
- status
- brand, model

### 2. 客户模型 (Customer)
**表名**: customers
**主键**: id (BigAutoField)

| 字段名 | 类型 | 长度 | 约束 | 说明 |
|--------|------|------|------|------|
| name | CharField | 100 | NOT NULL | 客户姓名 |
| phone | CharField | 20 | NOT NULL, UNIQUE | 联系电话 |
| email | EmailField | 254 | NULL | 邮箱地址 |
| id_card | CharField | 18 | UNIQUE, NOT NULL | 身份证号 |
| license_number | CharField | 20 | UNIQUE, NOT NULL | 驾照号 |
| license_type | CharField | 10 | NOT NULL, 有选择项 | 驾照类型 |
| member_level | CharField | 20 | NOT NULL, 有选择项 | 会员等级 |
| created_at | DateTimeField | - | NOT NULL | 创建时间 |
| updated_at | DateTimeField | - | NOT NULL | 更新时间 |

**驾照类型选项**:
- A: A类驾照
- B: B类驾照  
- C: C类驾照

**会员等级选项**:
- NORMAL: 普通会员
- VIP: VIP会员

**索引**:
- id_card (UNIQUE)
- license_number (UNIQUE)
- phone (UNIQUE)
- member_level

### 3. 租赁订单模型 (Rental)
**表名**: rentals
**主键**: id (BigAutoField)

| 字段名 | 类型 | 长度 | 约束 | 说明 |
|--------|------|------|------|------|
| customer_id | BigInteger | - | FK -> customers.id, CASCADE | 客户ID（外键）|
| vehicle_id | BigInteger | - | FK -> vehicles.id, CASCADE | 车辆ID（外键）|
| start_date | DateField | - | NOT NULL | 租赁开始日期 |
| end_date | DateField | - | NOT NULL | 租赁结束日期 |
| actual_return_date | DateField | - | NULL | 实际还车日期 |
| total_amount | DecimalField | 10,2 | NOT NULL, MIN>0 | 总金额 |
| status | CharField | 20 | NOT NULL, 有选择项 | 订单状态 |
| notes | TextField | - | NULL | 备注信息 |
| created_at | DateTimeField | - | NOT NULL | 创建时间 |
| updated_at | DateTimeField | - | NOT NULL | 更新时间 |

**订单状态选项**:
- PENDING: 预订中
- ONGOING: 进行中
- COMPLETED: 已完成
- CANCELLED: 已取消

**外键约束**:
- customer_id -> customers.id (级联删除)
- vehicle_id -> vehicles.id (级联删除)

**索引**:
- start_date
- end_date
- status
- customer_id
- vehicle_id
- customer_id, status
- vehicle_id, status

## 业务逻辑

### 数据验证
1. **Vehicle模型**:
   - 日租金必须大于0
   - 车牌号唯一
   - 状态有明确选择项

2. **Customer模型**:
   - 手机号格式验证（11位中国手机号）
   - 身份证号格式验证（18位标准格式）
   - 车牌号、身份证号、驾照号唯一
   - 会员等级和驾照类型有明确选择项

3. **Rental模型**:
   - 结束日期不能早于开始日期
   - 实际还车日期不能早于开始日期，不能晚于今天
   - 自动计算总金额 = 日租金 × 租赁天数
   - 包含自定义验证方法 clean()

### 数据关联
- 客户可以有多条租赁记录（1:N）
- 车辆可以有多条租赁记录（1:N）
- 支持反向查询通过 `customer.rentals` 和 `vehicle.rentals`

## 测试数据

已创建以下测试数据：
- **4辆车**: 包括大众帕萨特、丰田凯美瑞、本田CR-V、奔驰E级
- **4个客户**: 包含不同驾照类型和会员等级
- **3个租赁订单**: 涵盖不同状态（已完成、进行中、预订中）

## 数据库性能优化

1. **索引优化**:
   - 所有外键字段都有索引
   - 查询频繁的字段（状态、日期）创建了索引
   - 唯一性字段自动创建唯一索引

2. **数据类型优化**:
   - 使用BigAutoField作为主键
   - 金额字段使用DecimalField保证精度
   - 日期时间字段使用专门的Date/DateTimeField

## 使用示例

```python
# 查询可用车辆
available_vehicles = Vehicle.objects.filter(status='AVAILABLE')

# 查询VIP客户的订单
vip_rentals = Rental.objects.filter(customer__member_level='VIP')

# 获取客户的租赁历史
customer = Customer.objects.get(name='张三')
for rental in customer.rentals.all():
    print(f"租赁车辆: {rental.vehicle.license_plate}")
```

## 文件结构
```
car_rental_system/
├── vehicles/
│   ├── models.py          # 车辆模型
│   └── migrations/
│       └── 0001_initial.py
├── customers/
│   ├── models.py          # 客户模型
│   └── migrations/
│       └── 0001_initial.py
├── rentals/
│   ├── models.py          # 租赁订单模型
│   └── migrations/
│       └── 0001_initial.py
├── create_test_data.py    # 测试数据创建脚本
├── test_models.py         # 模型测试脚本
└── db.sqlite3             # SQLite数据库文件
```

## 总结
数据库设计遵循Django最佳实践，包含：
- 完整的字段定义和约束
- 适当的验证机制
- 良好的索引设计
- 清晰的外键关系
- 丰富的测试数据
- 详细的业务逻辑